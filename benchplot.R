## Nice bar plot of grouping benchmark timings based on Matt Dowle scripts from 2014
## https://github.com/h2oai/db-benchmark/commit/fce1b8c9177afb49471fcf483a438f619f1a992b
## Original grouping benchmark can be found in: https://github.com/Rdatatable/data.table/wiki/Benchmarks-:-Grouping

library(data.table)
if (!capabilities()[["X11"]] && capabilities()[["cairo"]]) options(bitmapType="cairo") # fix for R compiled with-x=no with-cairo=yes

solution.colors = rbindlist(list(
  list(solution="dplyr", colmain="red", collight="#FF7777"),
  list(solution="data.table", "blue", "#7777FF"),
  list(solution="pandas", "green4", "#77FF77"),
  list(solution="pydatatable", "darkorange", "orange"),
  list(solution="spark", "#8000FFFF", "#CC66FF"),
  list(solution="dask", "slategrey", "lightgrey"),
  list(solution="juliadf", "deepskyblue", "darkturquoise"),
  list(solution="clickhouse", "hotpink4", "hotpink1"),
  list(solution="cudf", "peachpuff3", "peachpuff1")
), use.names=FALSE)
## used to create github labels in db-benchmark project repo
#hexcol = function(x) sapply(x, function(x) paste0("#", paste(as.raw(col2rgb(x)), collapse="")))
#hexcol(setNames(solution.colors$collight, solution.colors$solution))

format_comma = function(x) format(as.integer(signif(x,4)), big.mark=",")
data_spec = function(data) {
  fe = file.exists(f<-file.path("data", paste(data,"csv",sep=".")))
  if (fe) {
    gb = file.info(f)$size/1024^3
    gb = if (gb<1) round(gb, 1) else round(gb)
    ncol = ncol(fread(f, nrows = 0L, showProgress=FALSE))
  } else {
    gb = "NA"
    ncol = "NA"
  }
  list(gb=gb, ncol=ncol)
}

get_xlab_values = function(x) {
  at = pretty(x, 8, 4)
  at[at!=0]
}

get_xlab_timescale = function(x) {
  if (x > 2*60*60) {
    timescale = 3600
    xlab = "Hours"
  } else if (x > 120) {
    timescale = 60
    xlab = "Minutes"
  } else {
    timescale = 1
    xlab = "Seconds"
  }
  setNames(timescale, xlab)
}

textBG = function(x, y, txt, w, ...) {
  txtw = strwidth(txt, ...); txth = strheight(txt, ...);
  txty = y-2*w;  # w from calling scope above
  rect(x, txty, x+txtw, txty+1.8*txth, col="white", border=NA)
  text(x, y, txt, adj=c(0, 0.7), xpd=NA, ...)
}

solution_name = function(solution, where) {
  if (solution=="pydatatable" && where=="legend") "(py)datatable"
  else if (solution=="juliadf" && where=="legend") "DataFrames.jl"
  else if (solution=="juliadf" && where=="margin") "DF.jl"
  else if (solution=="clickhouse" && where=="legend") "ClickHouse"
  else if (solution=="cudf") "cuDF"
  else solution
}

# legend solutions total time exceptions
get_exception2 = function(ex, s, d, q) {
  heading = function(x) trimws(sapply(strsplit(x, ":", fixed=TRUE), `[[`, 1L))
  which = c("data","query")
  if ("data" %in% which) {
    e = ex$data[[as.character(s)]]
    if (length(e)) {
      this = which(sapply(e, function(ee) any(as.character(d) %in% ee)))[1L]
      if (!is.na(this)) return(heading(names(e[this])))
    }
  }
  if ("query" %in% which) {
    e = ex$query[[as.character(s)]]
    if (length(e)) {
      this = which(sapply(e, function(ee) any(as.character(q) %in% ee)))[1L]
      if (!is.na(this)) return(heading(names(e[this])))
    }
  }
  return("")
}

# right aligned legend text entries for rightmost legend column, time
legendr = function(x, y=NULL, legend, cex, xpd, ...) {
  temp <- legend(x, y=y,
                 legend = rep("", length(legend)),
                 text.width = max(strwidth(legend)),
                 cex = cex,
                 xpd = xpd,
                 ...)
  text(temp$rect$left + temp$rect$w, temp$text$y,
       legend, pos=2, cex=cex, xpd=xpd, adj=1)
}

# limit axis values for cutoff
limit_x = function(x, lim) {
  x[x > lim] = lim # do not plot bar outside plot region to not overlap on timing values on margin
  x
}

format_num = function(x, digits=3L) { # at least 3+1 chars on output, there is surely some setting to achieve that better with base R but it is not obvious to find that among all features there
  cx = sprintf("%0.2f", x)
  int = sapply(strsplit(cx, ".", fixed=TRUE), `[`, 1L)
  int_digits = sapply(int, nchar)
  stopifnot(int_digits > 0L)
  cx[int_digits == 2L] = substr(cx[int_digits == 2L], 1L, 4L)
  cx[int_digits > 2L] = int[int_digits > 2L]
  cx
}

if (!interactive()) browser = function(...) stop("some new exception in data to handle in benchplot, go interactive mode")

# .nrow default Inf, numeric to filter out timingsto single in_rows, Inf will results to use maximum in_rows from timings
# task default "groupby", character scalar to filter out timings to single task, currently benchplot is used only for groupby task
# timings data.table of timings, structure as generated by `run.sh` script
# code list of syntax for solutions grouped by questions so syntax can be plotted next to the bars
# exceptions list of exceptions for solutions, see report-code.R
# colors data.table of solutions and colors assigned to them
# cutoff character name of solution to cutoff all longer timings
# cutoff.after numeric default 0.2, to cutoff after 120% percent of timing of solution provided to 'cutoff' argument, provide 0.5 for 150% and so on
# .interactive default interactive(), when TRUE it will print some output to console and open png after finished
# fnam fixed filename if do not want to generate from pattern
benchplot = function(.nrow=Inf, task, data, timings, code, exceptions, colors, cutoff="spark", cutoff.after=0.2, .interactive=interactive(), fnam=NULL, path="public/dev/plots") {
  stopifnot(c("task","time_sec_1","time_sec_2","question","question_group","solution","in_rows","out_rows","out_cols","version","git","batch") %in% names(timings))
  unlink(file.path(path, fnam))
  stopifnot(is.character(task), length(task)==1L, !is.na(task))
  if (!is.data.table(colors)) stop("argument colors must be data.table of solutions and colors assigned to each")
  if (!is.character(cutoff) || length(cutoff)>1) stop("cutoff must be character of length 0 to 1")
  if (missing(code)) stop("provide 'code' argument, list of questions and respective queries in each solution")
  if (missing(exceptions)) stop("provide 'exceptions' argument, list of query and data exceptions for each solution")
  if (!nrow(timings)) {
    message(sprintf("Benchplot skipped as nothing to plot for %s %s", task, data))
    return(invisible(NULL))
  }
  timings.task = unique(timings$task)
  if (length(intersect(timings.task, task))!=1L) stop("there should be only single task to present on benchplot, provide 'task' argument which exists in 'timings' dataset")
  # filter timings to single task
  timings = timings[task==timings.task]

  # if no .nrow argument provided then use maximum in_rows in timings
  if (!is.finite(.nrow)) .nrow = timings[, max(as.numeric(in_rows))]

  # filter timings to single data
  .data = data; rm(data)
  timings = timings[data==.data]

  if (!nrow(timings)) {
    message(sprintf("Benchplot skipped as nothing to plot for %s %s", task, .data))
    return(invisible(NULL))
  }

  if (timings[, all(is.na(c(time_sec_1, time_sec_2)))]) {
    message(sprintf("Benchplot skipped as all timings are NAs, nothing to plot for %s %s", task, .data))
    return(invisible(NULL))
  }
  if (timings[!is.na(time_sec_1), uniqueN(solution)] < 2L) {
    message(sprintf("Benchplot skipped as there is only single solution to plot for %s %s", task, .data))
    return(invisible(NULL))
  }

  if (uniqueN(timings$in_rows) != 1L) stop("There should be only single 'in_rows' after filtering on 'data'")

  questions = unique(na.omit(timings$question)) # NA questions for those who failed
  nquestions = length(questions)
  if (nquestions > 5L)
    stop("Number of questions to plot should be at most 5, run benchplot on a subset of 5 questions")

  if (!all(code_q_ok<-as.character(questions) %in% names(code)))
    stop(sprintf("Some question(s) does not have corresponding entry in argument 'code': %s", paste(questions[!code_q_ok], collapse=", ")))
  data = as.character(unique(timings$data))
  ndata = length(data)
  if (ndata!=1L) stop("only single 'data' field supported, run benchplot for each 'data'")

  timings[na_time_sec==TRUE, c("time_sec_1","time_sec_2") := NA_real_] # if any of timings failed do not plot just one

  solutions = unique(timings$solution)
  if (!all(code_q_s_ok<-sapply(code[as.character(questions)], function(c_q) all(solutions%in%names(c_q)))))
    stop(sprintf("Some question(s) does not have corresponding entry for some solutions in argument 'code': %s", paste(questions[!code_q_s_ok], collapse=", ")))
  nsolutions = length(solutions)

  if (length(cutoff) && !cutoff%in%solutions) stop(sprintf("'cutoff' argument used but provided value '%s' is not a solution existing in timing data", cutoff))

  # keep only required columns
  timings = timings[, .SD, .SDcols=c("time_sec_1","time_sec_2","question","iquestion","solution","in_rows","out_rows","out_cols","version","git","batch")]

  if (missing(fnam) || is.null(fnam))
    stop("Provide filename in 'fnam' argument")
  if (!is.null(path)) {
    if (!dir.exists(path)) dir.create(path, recursive=TRUE)
    filepath = file.path(path, fnam)
  }
  if (.interactive) cat("Plotting to", filepath, "...\n")
  height = 750 + 125*nsolutions + 30; # 30 for legend entry for unsupported
  png(file=filepath, width=800, height=height)

  mar.top = 4.1+nsolutions+1 # +1 for unsupported solutions legend entry
  mar.bot = 3.3/nsolutions
  par(mar=c(mar.bot, 5.1, mar.top, 6.1)) # shift to the left: c(bottom, left, top, right)

  # veriyfy colors unique and defined for every solution
  stopifnot(colors[, .N==1L, .(solution, colmain, collight)]$V1)
  timings[colors, c("colmain","collight") := list(i.colmain, i.collight), on="solution"]
  stopifnot(timings[is.na(colmain) | is.na(collight), .N==0L])

  # cutoff
  .cutoff = cutoff; rm(cutoff)
  timings[, c("cutoff_1","cutoff_2"):=FALSE]
  if (length(.cutoff)) {
    cutoff.time = if (timings[solution==.cutoff, all(is.na(c(time_sec_1, time_sec_2)))]) { # if all .cutoff timings are NAs use cutoff=max of all thus no cutoff
      timings[, max(c(time_sec_1, time_sec_2), na.rm=TRUE)]
    } else {
      timings[solution==.cutoff, max(c(time_sec_1, time_sec_2), na.rm=TRUE)]
    }
    cutoff.time.after = cutoff.time * (1+cutoff.after)
    if (is.na(cutoff.time)) stop("cutoff.time value is NA")
    timings[time_sec_1 > cutoff.time.after, "cutoff_1":=TRUE]
    timings[time_sec_2 > cutoff.time.after, "cutoff_2":=TRUE]
  }

  # define units of measure on X axis
  timescale = get_xlab_timescale(timings[, max(c(time_sec_1[cutoff_1==FALSE], time_sec_2[cutoff_2==FALSE]), na.rm=TRUE)])

  # prepare timings in expected unit of measure
  timings[, bars_1:=time_sec_1/timescale][, cutoff_bars_1:=bars_1][cutoff_1==TRUE, bars_1:=NA_real_]
  timings[, bars_2:=time_sec_2/timescale][, cutoff_bars_2:=bars_2][cutoff_2==TRUE, bars_2:=NA_real_]
  cutoff.bars.after = if (length(.cutoff)) cutoff.time.after/timescale else 0

  # X axis values
  x_at = timings[, get_xlab_values(c(bars_1, bars_2, cutoff.bars.after))]
  x_step = x_at[2L]-x_at[1L]
  offset_x = x_step/2
  x_at_last = x_at[length(x_at)]

  # order for bar horiz=TRUE does first bar from the bottom!
  ans = timings[, .SD][, max_time_sec:=max(c(time_sec_1, time_sec_2)), by=.(solution, question)][order(iquestion, max_time_sec, solution, na.last=FALSE, decreasing=TRUE)]

  # use padding to reserve extra space, this is order from bottom to up due to horiz=TRUE
  qpad = function(i, nsolutions) {
    c(as.vector(rbind(
      i*nsolutions+1:nsolutions,  ## solution time bar
      NA)),                       ## solution syntax
      NA,                         ## question header
      NA                          ## axis
    )
  }
  pad = as.vector(sapply(
    seq.int(nquestions)-1L, # time  for solution syntax, and top X axis and its labels
    qpad, nsolutions = nsolutions
  ))
  # get bars coordinates, plot positions only
  tt = barplot(rep(NA_real_, nrow(ans))[pad], horiz=TRUE, xlim=c(0,x_at_last), axes=FALSE)

  # we reverse `tt` as horiz=TRUE does first bar from the bottom
  tt = rev(tt)
  # calculate half of bar width used later on in many places
  tt_step = tt[1L]-tt[2L]
  w = tt_step/4

  # upper horizontal line of X axis, separate legend from barplots
  h1 = tt[1L]
  abline(h=h1)
  # X axis upper label (seconds, minutes) and values
  ff = if (length(x_at)<=8L) TRUE else -1  # ff = first first X axis label overlap, so conditionally exclude
  text(x=x_at[ff],  y=h1, labels=format(x_at[ff]), adj=c(0.5, -0.5), cex=1.5, font=2, xpd=NA)
  text(x=-offset_x, y=h1, labels=names(timescale), adj=c(0,   -0.5), cex=1.5, font=2, xpd=NA)

  # bottom horizontal line of X axis
  h2 = tail(tt, 1L)-4*w
  abline(h=h2)
  # X axis lower label (seconds/minutes) and values
  text(x=x_at[ff],  y=h2, labels=format(x_at[ff]), adj=c(0.5, 1.5), cex=1.5, font=2, xpd=NA)
  text(x=-offset_x, y=h2, labels=names(timescale), adj=c(0,   1.5), cex=1.5, font=2, xpd=NA)

  space = nsolutions*2L + 2L
  # grey horizontal lines separating questions
  abline(h=tt[seq(space+1L, by=space, length=4L)], col="grey", lwd=2)
  # dotted vertical lines to form grid
  for (at_x in x_at) lines(x=c(at_x, at_x), y=c(h1, h2), col="lightgrey", lwd=2, lty="dotted")

  # first run bars
  ans[, barplot(limit_x(x=cutoff_bars_1, lim=x_at_last)[pad],
                horiz=TRUE, axes=FALSE,
                col=c(colmain,"black")[pad],
                font=2, xpd=NA, add=TRUE)]

  # for each question remaining plotting
  get_exception = function(e, s, key) {
    if (!s %in% names(e)) stop(sprintf("missing exception for %s", s))
    if (!length(e[[s]])) return(character())
    ex = sapply(e[[s]], function(vec, key) sum(key%in%vec), key)
    sum_ex = sum(ex)
    if (sum_ex>1L) stop(sprintf("exception for %s defined %d times for solution %s, must be defined at most once", key, sum_ex, s))
    else if (sum_ex==1L) names(ex[ex==1L])
    else character()
  }
  for (iq in 1L:nquestions) {
    # determine order of solutions according to max time_sec for this question
    q_ord_solutions = ans[question==questions[iq]][order(max_time_sec, solution, na.last=TRUE), as.character(solution)]
    if (interactive() && (!length(q_ord_solutions)==nsolutions)) browser()
    stopifnot(length(q_ord_solutions)==nsolutions)
    # plot solutions syntax above the timing bar and solution name on the margin
    for (is in 1L:nsolutions) {
      s = q_ord_solutions[is]
      cod = code[[as.character(questions[iq])]][[s]]
      col = colors[s, colmain, on="solution"]
      text_y = tt[is*2L+1L+(iq-1)*space]
      textBG(0, text_y, txt=cod, w=w, col=col, font=2)
      text(0, text_y-2*w, solution_name(s, where="margin"), col=col, font=2, xpd=NA, pos=2)
    }
    # plot question headers
    out_rows = ans[question==questions[iq], na.omit(out_rows)]
    if (length(unique(out_rows)) > 1L) if (interactive()) browser() else stop("out_rows mismatch") # len 0 when none completed answers for this question
    out_cols = ans[question==questions[iq], na.omit(out_cols)]
    if (length(unique(out_cols)) > 1L) stop("out_cols mismatch")
    if (timings.task=="groupby") {
      qtxt = sprintf("Question %s: %s ad hoc groups of %s rows;  result %s x %s", iq, format_comma(out_rows[1L]), format_comma(.nrow/out_rows[1L]), format_comma(out_rows[1L]), out_cols[1L])
    } else if (timings.task=="join") {
      qtxt = sprintf("Question %s: result %s x %s", iq, format_comma(out_rows[1L]), out_cols[1L])
    } else {
      stop(sprintf("task %s has to be defined in plot question headers in benchplot", timings.task))
    }
    textBG(0, tt[2+(iq-1)*space], w=w, font=2, txt=qtxt)
    # second timing bars
    for (is in 1L:nsolutions) {
      s = q_ord_solutions[is]
      val = ans[solution==s & question==questions[iq], cutoff_bars_2]
      at = tt[(is+1)*2+(iq-1)*space]
      if (!is.na(val)) {
        if (val > x_at_last) val = x_at_last # do not plot bar outside plot region to not overlap on timing values on margin
        rect(0, at-w, val, at+w, col=colors[s, collight, on="solution"], xpd=NA)
      } else {
        exception = get_exception(exceptions$query, s, questions[iq])
        if (!length(exception)) exception = get_exception(exceptions$data, s, data)
        if (!length(exception)) exception = "undefined exception"
        textBG(0, tt[(is+1)*2+(iq-1)*space], txt=exception, w=w, col=colors[s, colmain, on="solution"], font=2)
      }
    }
  }

  # plot timing values next to each bar
  max_t = ans[, pmax(cutoff_bars_1, cutoff_bars_2)]
  both_t = ans[, paste(format_num(c(cutoff_bars_1, cutoff_bars_2)), collapse="; "), by=c("solution","question")]$V1  # print both runs timings #31 (unless same), round to 2 decimals places to avoid 0.0 cases
  stopifnot(length(max_t)==length(both_t))
  max_t_x_pos = max_t
  if (length(.cutoff) && length(cutoff.i<-which(max_t>cutoff.bars.after))) {
    both_t[cutoff.i] = paste("...", both_t[cutoff.i])
    max_t_x_pos[cutoff.i] = limit_x(x=max_t_x_pos[cutoff.i], lim=x_at_last) #cutoff.bars.after, on right margin
  }
  max_t_y_pos = rev(tt)[!is.na(pad)]-w/2
  text(max_t_x_pos, max_t_y_pos, both_t, pos=4, cex=1.25, xpd=NA)

  # legend
  topoffset = (nsolutions+1L)*5                    # +1 for unsupported solutions last legend entry
  legend_y_header = par()$usr[4]+topoffset*w - w # usr: c(x1, x2, y1, y2)
  legend_y_table = legend_y_header - 2*w

  # legend header
  ds = data_spec(data)
  legend_header = sprintf(
    "Input table: %s rows x %s columns ( %s GB )",
    format_comma(.nrow),
    ds[["ncol"]],
    ds[["gb"]]
  )
  text(-offset_x, legend_y_header,
       labels = legend_header,
       adj=c(0, 1), #pos=4,
       cex=1.5, font=2, xpd=NA)

  # first, second timing top right legend
  legend(x_at_last-x_step, tt[1L]+tt_step*3, pch=22, xpd=NA, bty="n", pt.lwd=1, cex=1.5,
         yjust = 0,
         legend=c("First time","Second time"), pt.cex=c(3.5, 2.5),
         pt.bg=colors[solution=="data.table", c(colmain, collight)])

  # solutions legend
  ans[, .(total_time_sec = sum(c(time_sec_1, time_sec_2)), # total time of run 1 and run 2 for all questions
          batch=min(batch), version=version[1], git=git[1], colmain=colmain[1]), # batch=min(batch) in case different data tested in different benchmark runs, earliest is taken, as for all runs there should same version so we need a date of earliest run of that version
      keyby="solution"
      ][, "na_total_time" := is.na(total_time_sec)
        ][order(total_time_sec, na.last=TRUE)
          ][, .(
            colmain, na_total_time,
            ## legend columns
            lg1 = solution_name(as.character(solution), "legend"),
            lg2 = as.character(version),
            lg3 = format(as.Date(as.POSIXct(as.numeric(batch), origin="1970-01-01"))),
            lg4 = if (na_total_time) get_exception2(exceptions, solution, .data, questions) else sprintf("%.0fs", total_time_sec)
          ), by="solution"] -> lg
  # extra list of solutions that are not part of the benchmark yet, there are here because users asked for them
  unsupported = c("Modin")
  lg_unsupported = data.table(
    solution="unsupported",
    colmain="black",
    na_total_time = TRUE,
    lg1 = paste(unsupported, collapse=", "),
    lg2 = "",
    lg3 = "see README",
    lg4 = "pending"
  )
  lg = rbindlist(list(lg, lg_unsupported))

  # legend formed into aligned columns
  le = -offset_x               # left end
  re = x_at_last - 3*offset_x  # right end
  anoff = seq(0, re-le, by=(re-le)/100) # offset to an offset for legend columns X location
  lg[, legend(le + anoff[1L], legend_y_table, bty="n", cex=1.5,
              pch=22, pt.bg=colmain, pt.cex=3.5,        ## color square
              text.font=1, xpd=NA, legend=lg1)] -> nul  ## solution
  lg[, legend(le + anoff[31L], legend_y_table, bty="n", cex=1.5,
              text.font=1, xpd=NA, legend=lg2)] -> nul  ## version
  lg[, legend(le + anoff[51L], legend_y_table, bty="n", cex=1.5,
              text.font=1, xpd=NA, legend=lg3)] -> nul  ## date
  lg[, legendr(le + anoff[81L], legend_y_table, bty="n", cex=1.5,
               text.font=1, xpd=NA, legend=lg4)] -> nul ## time

  # footer link to report
  text(0-1.5*offset_x, par()$usr[3]+0.15, "https://h2oai.github.io/db-benchmark", pos=4, xpd=NA)
  # footer timestamp of plot gen
  text(x_at_last+1.5*offset_x, par()$usr[3]+0.15, format(Sys.time(), usetz=TRUE), pos=2, xpd=NA)
  # finish png
  dev.off()
  if (.interactive) system(paste("/usr/bin/xdg-open", filepath), wait=FALSE) else invisible(TRUE)
}

if (dev<-FALSE) {

  #source("benchplot.R")
  .interactive = TRUE
  source("report.R")
  source("report-code.R")
  ld = time_logs()

  # groupby
  q_group = "basic"
  .nrow=1e7; data="G1_1e7_1e2_0_0";
  benchplot(.nrow=.nrow, task="groupby", data=data, timings=ld[task=="groupby" & script_recent==TRUE & question_group==q_group], code=groupby.code, exceptions=groupby.exceptions, colors=solution.colors, .interactive=.interactive, fnam=paste("dev", data, "png", sep="."))
  .nrow=1e8; data="G1_1e8_1e1_0_0";
  benchplot(.nrow=.nrow, task="groupby", data=data, timings=ld[task=="groupby" & script_recent==TRUE & question_group==q_group], code=groupby.code, exceptions=groupby.exceptions, colors=solution.colors, .interactive=.interactive, fnam=paste("dev", data, "png", sep="."))
  .nrow=1e9; data="G1_1e9_2e0_0_0";
  benchplot(.nrow=.nrow, task="groupby", data=data, timings=ld[task=="groupby" & script_recent==TRUE & question_group==q_group], code=groupby.code, exceptions=groupby.exceptions, colors=solution.colors, .interactive=.interactive, fnam=paste("dev", data, "png", sep="."))

  # join
  q_group = "basic"
  .nrow=1e7; data="J1_1e7_NA_0_0";
  benchplot(.nrow=.nrow, task="join", data=data, timings=ld[task=="join" & script_recent==TRUE & question_group==q_group], code=join.code, exceptions=join.exceptions, colors=solution.colors, .interactive=.interactive, fnam=paste("dev", data, "png", sep="."))
  .nrow=1e8; data="J1_1e8_NA_0_0";
  benchplot(.nrow=.nrow, task="join", data=data, timings=ld[task=="join" & script_recent==TRUE & question_group==q_group], code=join.code, exceptions=join.exceptions, colors=solution.colors, .interactive=.interactive, fnam=paste("dev", data, "png", sep="."))

}
